)
## Now let's add a confidence interval to the loess() fit...
plot(
data,
type="n",
frame.plot=FALSE,
xlab="",
ylab="",
col="#d95f0e",
lwd=1.5
)
polygon(
c(x, rev(x)),
c(
plx$fit + qt(0.975,plx$df)*plx$se,
rev(plx$fit - qt(0.975,plx$df)*plx$se)
),
col="#99999977"
)
points(
data,
col="#d95f0e",
lwd=1.5
)
lines(
x,
plx$fit,
col="black",
lwd=3
)
data |>
ggplot(aes(x, y.norm)) +
geom_point() +
geom_smooth(span = 1/5)
mouse.data <- data.frame(
size = c(1.4, 2.6, 1.0, 3.7, 5.5, 3.2, 3.0, 4.9, 6.3),
weight = c(0.9, 1.8, 2.4, 3.5, 3.9, 4.4, 5.1, 5.6, 6.3),
tail = c(0.7, 1.3, 0.7, 2.0, 3.6, 3.0, 2.9, 3.9, 4.0))
mouse.data # print the data to the screen in a nice format
## STEP 1: Draw a graph of the data to make sure the relationship make sense
plot(mouse.data$weight, mouse.data$size)
## STEP 2: Do the regression
simple.regression <- lm(size ~ weight, data=mouse.data)
## STEP 3: Look at the R^2, F-value and p-value
summary(simple.regression)
## add the regression line to our x/y scatter plot
abline(simple.regression, col="purple")
## now let's verify that our formula for R^2 is correct..
ss.mean <- sum((mouse.data$size - mean(mouse.data$size))^2)
ss.simple <- sum(simple.regression$residuals^2)
(ss.mean - ss.simple) / ss.mean # this is the R^2 value
## now let's verify the our formula for F is correct...
f.simple <- ((ss.mean - ss.simple) / (2 - 1)) /
(ss.simple / (nrow(mouse.data) - 2))
f.simple # this is the F-value
## First, draw the correct f-distribution curve with df1=1 and df2=7
x <- seq(from=0, to=15, by=0.1)
y <- df(x, df1=1, df2=7)
plot(x, y, type="l")
## now draw a vertical line where our F-value, f.simple, is.
abline(v=f.simple, col="purple")
## color the graph on the left side of the line blue
x.zero.to.line <- seq(from=0, to=f.simple, by=0.1)
y.zero.to.line <- df(x.zero.to.line, df1=1, df2=7)
polygon(x=c(x.zero.to.line, 0), y=c(y.zero.to.line, 0), col="lightblue")
## color the graph on the right side of the line red
x.line.to.20 <- seq(from=f.simple, to=20, by=0.1)
y.line.to.20 <- df(x.line.to.20, df1=1, df2=7)
polygon(x=c(x.line.to.20, f.simple), y=c(y.line.to.20, 0), col="purple")
pf(f.simple, df1=1, df2=7) ## the area under the curve that is blue
1-pf(f.simple, df1=1, df2=7) ## the area under the curve that is red
## compare this p-value to the one from the
## original regression
#| echo: false
curve(df(x, df1=1, df2=7), from=0, to=5)
## STEP 1: Draw a graph of the data to make sure the relationship make sense
## This graph is more complex because it shows the relationships between all
## of the columns in "mouse.data".
plot(mouse.data)
## STEP 2: Do the regression
multiple.regression <- lm(size ~ weight + tail, data=mouse.data)
## STEP 3: Look at the R^2, F-value and p-value
summary(multiple.regression)
## again, we can verify that our R^2 value is what we think it is
ss.multiple <- sum(multiple.regression$residuals^2)
(ss.mean - ss.multiple) / ss.mean
## we can also verify that the F-value is what we think it is
f.multiple <- ((ss.mean - ss.multiple) / (3 - 1)) /
(ss.multiple / (nrow(mouse.data) - 3))
f.multiple
## Again let's draw a figure that shows how to calculate the p-value from the
## F-value
##
## First, draw the correct f-distribution curve with df1=2 and df2=6
x <- seq(from=0, to=20, by=0.1)
y <- df(x, df1=2, df2=6)
plot(x, y, type="l")
## now draw a verticle line where our f.value is for this test
abline(v=f.multiple, col="purple")
## color the graph on the left side of the line blue
x.zero.to.line <- seq(from=0, to=f.multiple, by=0.1)
y.zero.to.line <- df(x.zero.to.line, df1=2, df2=6)
polygon(x=c(x.zero.to.line, 0), y=c(y.zero.to.line, 0), col="lightblue")
## color the graph on the right side of the line red
x.line.to.20 <- seq(from=f.multiple, to=20, by=0.1)
y.line.to.20 <- df(x.line.to.20, df1=2, df2=6)
polygon(x=c(x.line.to.20, f.multiple), y=c(y.line.to.20, 0), col="purple")
pf(f.multiple, df1=2, df2=6) ## the area under the curve that is blue
1-pf(f.multiple, df1=2, df2=6) ## the area under the curve that is red
## lastly, let's compare this p-value to the one from the
## original regression
summary(multiple.regression)
f.simple.v.multiple <- ((ss.simple - ss.multiple) / (3-2)) /
(ss.multiple / (nrow(mouse.data) - 3))
1-pf(f.simple.v.multiple, df1=1, df2=6)
library(ggplot2)
# noisy gamma distribution plot
x <- seq(from = 0, to = 20, by = 0.1)
y.gamma <- dgamma(x, shape = 2, scale = 2)
y.gamma.scaled <- y.gamma * 100
y.norm <- vector(length = 201)
for (i in 1:201) {
y.norm[i] = rnorm(
n = 1,
mean = y.gamma.scaled[i],
sd = 2
)
}
data <- data.frame(x, y.norm)
data |>
ggplot(mapping = aes(
x,
y.norm
)) +
geom_point()
# by default "lowess()" fits a line in each window using 2/3's
# of the data points
# y.norm ~ x says that y.norm is being modeled by x
# f is the fraction of points to use in each window
lo.fit.gamma <- lowess(y.norm ~ x, f = 1/5)
plot(data,
frame.plot = F,
xlab = "",
ylab = "",
col = "#d95f0e",
lwd = 1.5
)
lines(x, lo.fit.gamma$y, col = "black", lwd = 3)
title("lowess() smoothing")
# by default "loess()" fits a parabola in each window using
# 75% of the data points
plx<-predict(
loess(y.norm ~ x,
span=1/5,
degree=2,
family="symmetric",
iterations=4
),
se=T
)
## Now let's add a confidence interval to the loess() fit...
plot(
data,
type="n",
frame.plot=FALSE,
xlab="",
ylab="",
col="#d95f0e",
lwd=1.5
)
polygon(
c(x, rev(x)),
c(
plx$fit + qt(0.975,plx$df)*plx$se,
rev(plx$fit - qt(0.975,plx$df)*plx$se)
),
col="#99999977"
)
points(
data,
col="#d95f0e",
lwd=1.5
)
lines(
x,
plx$fit,
col="black",
lwd=3
)
data |>
ggplot(aes(x, y.norm)) +
geom_point() +
geom_smooth(span = 1/5)
mouse.data <- data.frame(
size = c(1.4, 2.6, 1.0, 3.7, 5.5, 3.2, 3.0, 4.9, 6.3),
weight = c(0.9, 1.8, 2.4, 3.5, 3.9, 4.4, 5.1, 5.6, 6.3),
tail = c(0.7, 1.3, 0.7, 2.0, 3.6, 3.0, 2.9, 3.9, 4.0))
mouse.data # print the data to the screen in a nice format
## STEP 1: Draw a graph of the data to make sure the relationship make sense
plot(mouse.data$weight, mouse.data$size)
## STEP 2: Do the regression
simple.regression <- lm(size ~ weight, data=mouse.data)
## STEP 3: Look at the R^2, F-value and p-value
summary(simple.regression)
## add the regression line to our x/y scatter plot
abline(simple.regression, col="purple")
## now let's verify that our formula for R^2 is correct..
ss.mean <- sum((mouse.data$size - mean(mouse.data$size))^2)
ss.simple <- sum(simple.regression$residuals^2)
(ss.mean - ss.simple) / ss.mean # this is the R^2 value
## now let's verify the our formula for F is correct...
f.simple <- ((ss.mean - ss.simple) / (2 - 1)) /
(ss.simple / (nrow(mouse.data) - 2))
f.simple # this is the F-value
## First, draw the correct f-distribution curve with df1=1 and df2=7
x <- seq(from=0, to=15, by=0.1)
y <- df(x, df1=1, df2=7)
plot(x, y, type="l")
## now draw a vertical line where our F-value, f.simple, is.
abline(v=f.simple, col="purple")
## color the graph on the left side of the line blue
x.zero.to.line <- seq(from=0, to=f.simple, by=0.1)
y.zero.to.line <- df(x.zero.to.line, df1=1, df2=7)
polygon(x=c(x.zero.to.line, 0), y=c(y.zero.to.line, 0), col="lightblue")
## color the graph on the right side of the line red
x.line.to.20 <- seq(from=f.simple, to=20, by=0.1)
y.line.to.20 <- df(x.line.to.20, df1=1, df2=7)
polygon(x=c(x.line.to.20, f.simple), y=c(y.line.to.20, 0), col="purple")
pf(f.simple, df1=1, df2=7) ## the area under the curve that is blue
1-pf(f.simple, df1=1, df2=7) ## the area under the curve that is red
## compare this p-value to the one from the
## original regression
#| echo: false
curve(df(x, df1=1, df2=7), from=0, to=5)
## STEP 1: Draw a graph of the data to make sure the relationship make sense
## This graph is more complex because it shows the relationships between all
## of the columns in "mouse.data".
plot(mouse.data)
## STEP 2: Do the regression
multiple.regression <- lm(size ~ weight + tail, data=mouse.data)
## STEP 3: Look at the R^2, F-value and p-value
summary(multiple.regression)
## again, we can verify that our R^2 value is what we think it is
ss.multiple <- sum(multiple.regression$residuals^2)
(ss.mean - ss.multiple) / ss.mean
## we can also verify that the F-value is what we think it is
f.multiple <- ((ss.mean - ss.multiple) / (3 - 1)) /
(ss.multiple / (nrow(mouse.data) - 3))
f.multiple
## Again let's draw a figure that shows how to calculate the p-value from the
## F-value
##
## First, draw the correct f-distribution curve with df1=2 and df2=6
x <- seq(from=0, to=20, by=0.1)
y <- df(x, df1=2, df2=6)
plot(x, y, type="l")
## now draw a verticle line where our f.value is for this test
abline(v=f.multiple, col="purple")
## color the graph on the left side of the line blue
x.zero.to.line <- seq(from=0, to=f.multiple, by=0.1)
y.zero.to.line <- df(x.zero.to.line, df1=2, df2=6)
polygon(x=c(x.zero.to.line, 0), y=c(y.zero.to.line, 0), col="lightblue")
## color the graph on the right side of the line red
x.line.to.20 <- seq(from=f.multiple, to=20, by=0.1)
y.line.to.20 <- df(x.line.to.20, df1=2, df2=6)
polygon(x=c(x.line.to.20, f.multiple), y=c(y.line.to.20, 0), col="purple")
pf(f.multiple, df1=2, df2=6) ## the area under the curve that is blue
1-pf(f.multiple, df1=2, df2=6) ## the area under the curve that is red
## lastly, let's compare this p-value to the one from the
## original regression
summary(multiple.regression)
f.simple.v.multiple <- ((ss.simple - ss.multiple) / (3-2)) /
(ss.multiple / (nrow(mouse.data) - 3))
1-pf(f.simple.v.multiple, df1=1, df2=6)
library(tidyverse)
mpg |>
ggplot(aes(
mpg |>
ggplot(aes(
x = displ,
y = hwy,
color = class
)) +
geom_point()
mpg |>
ggplot(aes(
x = displ,
y = hwy,
color = class
)) +
geom_point()
mpg |>
ggplot(aes(
x = hwy,
y = displ,
)) +
geom_point(
shape = 17,
color = "pink",
size = 5
)
mpg |>
ggplot(aes(x = displ, y = hwy, colour = displ < 5)) +
geom_point()
{r}
mpg |>
ggplot(aes(x = displ, y = hwy, colour = displ < 5)) +
geom_point()
{r}
mpg |>
ggplot(aes(
x = displ,
y = hwy,
color = drv
)) +
geom_point() +
geom_smooth(aes(linetype = drv))
{r}
mpg |>
ggplot(aes(
x = displ,
y = hwy,
color = drv
)) +
geom_point() +
geom_smooth(aes(linetype = drv))
{r}
ggplot(mpg, aes(
x = displ,
y = hwy
)) +
geom_point() +
geom_point(
data = mpg |> filter(class == "2seater"),
color = "red"
) +
geom_point(
data = mpg |> filter(class == "2seater"),
shape = "circle open", size = 3, color = "red"
)
{r}
mpg |>
ggplot(aes(
x = hwy
)) +
geom_density()
getwd()
setwd("Interactive_Churn_Analytics/")
renv::activate()
library(tidyverse)
library(showtext)
font_add(family = "Symbola", regular = "/usr/share/fonts/TTF/Symbola.ttf")
showtext_auto()
theme_set(
theme_minimal(base_size = 12) +
theme(text = element_text(family = "Symbola"))
)
#| echo: false
df <- read.csv("../data/processed/customer_churn_data_clean.csv")
# Drop index/ID columns; keep the rest from your schema
df_use <- df |>
select(-X, -CustomerID)  # keep Churn, Age, Tenure, PhoneService, InternetService, Contract, MonthlyCharges, TotalCharges
# Ensure churn is a factor with "No/Yes" levels per schema
df_use <- df_use |>
mutate(Churn = factor(Churn, levels = c("No","Yes")))
names(df)
#| message: false
#| echo: false
num_cols <- df_use |>
select(where(is.numeric))
num_long <- num_cols |>
pivot_longer(everything(), names_to = "feature", values_to = "value")
ggplot(num_long, aes(value)) +
geom_histogram(bins = 30, fill = "#4C78A8", alpha = 0.85, color = "white") +
facet_wrap(~feature, scales = "free", ncol = 2) +
labs(
title = "Numeric Feature Distributions",
subtitle = "Age, Tenure, MonthlyCharges, TotalCharges",
x = NULL, y = "Count"
)
#| echo: false
num_long_churn <- df_use |>
select(Churn, where(is.numeric)) |>
pivot_longer(-Churn, names_to = "feature", values_to = "value") |>
drop_na(value)
ggplot(num_long_churn, aes(value, fill = Churn)) +
geom_density(alpha = 0.35) +
facet_wrap(~feature, scale = "free", ncol = 2) +
labs(
title = "Numeric Densities by Churn",
x = NULL,
y = "Density",
fill = "Churn"
)
#| echo: false
ggplot(num_long_churn, aes(x = Churn, y = value, fill = Churn)) +
geom_boxplot(outlier.alpha = 0.25, width = 0.7) +
facet_wrap(~ feature, scales = "free_y", ncol = 2) +
labs(title = "Numeric Spread & Outliers by Churn", x = NULL, y = NULL) +
guides(fill = "none")
#| echo: false
cat_cols <- df_use |>
select(where(~ is.character(.x) || is.factor(.x))) |>
select(-Churn)  # analyze service mix separately from the label
cat_long <- cat_cols |>
mutate(across(everything(), ~ fct_lump_n(factor(.x), n = 8, other_level = "Other"))) |>
pivot_longer(everything(), names_to = "feature", values_to = "level") |>
drop_na(level)
ggplot(cat_long, aes(level)) +
geom_bar(fill = "#72B7B2") +
facet_wrap(~ feature, scales = "free_y", ncol = 2) +
coord_flip() +
labs(title = "Categorical Feature Counts", x = NULL, y = "Count")
#| echo: false
cat_long_churn <- df_use |>
select(Churn, where(~ is.character(.x) || is.factor(.x))) |>
mutate(across(-Churn, ~ fct_lump_n(factor(.x), n = 6, other_level = "Other"))) |>
pivot_longer(-Churn, names_to = "feature", values_to = "level") |>
drop_na(level, Churn)
ggplot(cat_long_churn, aes(level, fill = Churn)) +
geom_bar(position = "fill") +
facet_wrap(~ feature, scales = "free_y", ncol = 2) +
coord_flip() +
scale_y_continuous(labels = scales::percent) +
labs(title = "Categorical Proportions by Churn", x = NULL, y = "Percent", fill = "Churn")
missing_df <- df_use |>
summarise(across(everything(), ~ sum(is.na(.)))) |>
pivot_longer(everything(), names_to = "feature", values_to = "n_missing") |>
mutate(pct = n_missing / nrow(df_use))
ggplot(missing_df, aes(reorder(feature, pct), pct)) +
geom_col(fill = "#E45756") +
coord_flip() +
scale_y_continuous(labels = scales::percent) +
labs(title = "Missing Values by Feature", x = NULL, y = "Percent Missing")
#| echo: false
num_long |>
group_by(feature) |>
summarise(
n = sum(!is.na(value)),
mean = mean(value, na.rm = TRUE),
median = median(value, na.rm = TRUE),
sd = sd(value, na.rm = TRUE),
p99 = quantile(value, 0.99, na.rm = TRUE),
skew_hint = case_when(
median < mean ~ "Right-skewed",
median > mean ~ "Left-skewed",
TRUE ~ "Roughly symmetric"
)
) |>
arrange(desc(abs(mean - median)))
#| echo: false
make_skew_plot <- function(df, feature) {
v <- df[[feature]]
d <- data.frame(value = v)
m   <- mean(v, na.rm = TRUE)
med <- median(v, na.rm = TRUE)
sdv <- sd(v, na.rm = TRUE)
skew <- if (is.na(sdv) || sdv == 0) NA_real_ else 3 * (m - med) / sdv
dir  <- if (m > med) "Right-skewed" else if (m < med) "Left-skewed" else "Symmetric"
label <- if (is.na(skew)) dir else sprintf("%s\nSkew â‰ˆ %.2f", dir, skew)
lines <- data.frame(
stat_type  = c("Mean", "Median"),
xintercept = c(m, med)
)
ggplot(d, aes(value)) +
geom_density(fill = "#4C78A8", alpha = 0.3) +
geom_vline(
data = lines,
aes(xintercept = xintercept, color = stat_type, linetype = stat_type),
linewidth = 0.9
) +
annotate("text", x = Inf, y = Inf, label = label, hjust = 1.05, vjust = 1.3, size = 3.5) +
labs(title = paste("Skewness:", feature), x = NULL, y = NULL,
color = "Statistic", linetype = "Statistic") +
scale_color_manual(values = c(Mean = "red", Median = "blue")) +
scale_linetype_manual(values = c(Mean = "dashed", Median = "dotted")) +
theme_minimal(base_size = 12) +
theme(legend.position = "bottom", plot.margin = margin(10, 20, 10, 10))
}
# Examples (separate plots):
p_age     <- make_skew_plot(df, "Age")
p_tenure  <- make_skew_plot(df, "Tenure")
p_monthly <- make_skew_plot(df, "MonthlyCharges")
p_total   <- make_skew_plot(df, "TotalCharges")
p_age; p_tenure; p_monthly; p_total
# Select the categorical features of interest
cat_features <- c("Gender", "PhoneService", "InternetService", "Contract")
cat_long_churn <- df_use %>%
select(Churn, all_of(cat_features)) %>%
pivot_longer(-Churn, names_to = "feature", values_to = "level") %>%
drop_na(level, Churn)
#| echo: false
ggplot(cat_long_churn, aes(level, fill = Churn)) +
geom_bar(position = "stack") +
facet_wrap(~ feature, scales = "free_x", ncol = 2) +
labs(
title = "Categorical Balances by Churn (Counts)",
x = NULL, y = "Count", fill = "Churn"
) +
theme_minimal(base_size = 12) +
theme(axis.text.x = element_text(angle = 20, hjust = 1))
#| echo: false
ggplot(cat_long_churn, aes(level, fill = Churn)) +
geom_bar(position = "fill") +
facet_wrap(~ feature, scales = "free_x", ncol = 2) +
scale_y_continuous(labels = scales::percent) +
labs(
title = "Categorical Balances by Churn (Proportions)",
x = NULL, y = "Percent", fill = "Churn"
) +
theme_minimal(base_size = 12) +
theme(axis.text.x = element_text(angle = 20, hjust = 1))
